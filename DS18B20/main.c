#define F_CPU 9600000UL // F_CPU = 9.6 МГц (Low Fuse=0x7A, CKDIV8=1, HighFuse=0xFF).
#ifndef __AVR_ATtiny13__
#define __AVR_ATtiny13__  // Указание модели микроконтроллера ATtiny13
#endif
#include <avr/io.h>      // Библиотека для работы с I/O портами
#include <util/delay.h>  // Библиотека для функций задержек

// Определение пинов и констант
#define PIN_DS1820 PB3   // Пин для подключения датчика температуры DS18B20
#define PIN_RELAY PB4    // Пин для управления реле
#define PIN_UART_TX PB1  // Пин для передачи данных по UART (MISO)
// Верхний порог температуры (45°C)
#define TEMP_UPPER_THRESHOLD 45   
// Нижний порог температуры (40°C)
#define TEMP_LOWER_THRESHOLD 40          
#define MAX_SENSORS 4  // Максимальное количество поддерживаемых датчиков 4
#define BAUD 9600      // Скорость передачи данных по UART (бит/с)
#define UART_DELAY (1000000UL / BAUD)  // Длительность бита в микросекундах

/**
 * Сброс шины OneWire и проверка наличия устройств
 *
 * Процедура:
 * 1. Устанавливает линию данных в низкое состояние на 480 мкс (reset pulse)
 * 2. Переводит линию в режим чтения и подтягивает её к питанию
 * 3. Ожидает 70 мкс и проверяет наличие ответа от устройств (presence pulse)
 *
 * @return 1 если устройство обнаружено, 0 если устройств нет
 */
static inline uint8_t oneWireReset(void) {
    DDRB |= (1 << PIN_DS1820);                     // Настройка пина как выход
    PORTB &= ~(1 << PIN_DS1820);                   // Установка низкого уровня (reset pulse)
    _delay_us(480);                                // Задержка 480 мкс (минимум 480 мкс для сброса)
    DDRB &= ~(1 << PIN_DS1820);                    // Настройка пина как вход
    PORTB |= (1 << PIN_DS1820);                    // Включение подтягивающего резистора
    _delay_us(70);                                 // Ожидание ответа от устройства
    uint8_t result = !(PINB & (1 << PIN_DS1820));  // Проверка наличия presence pulse (низкий уровень)
    _delay_us(410);                                // Ожидание окончания цикла сброса
    return result;                                 // Возврат результата
}

/**
 * Запись одного бита в шину OneWire
 *
 * Для записи 1:
 * - Устанавливает низкий уровень на 1-15 мкс, затем высокий на оставшееся время
 * Для записи 0:
 * - Устанавливает низкий уровень на 60-120 мкс
 *
 * @param bit значение бита для записи (0 или 1)
 */
static inline void oneWireWriteBit(uint8_t bit) {
    DDRB |= (1 << PIN_DS1820);    // Настройка пина как выход
    PORTB &= ~(1 << PIN_DS1820);  // Установка низкого уровня
    if (bit) {
        _delay_us(1);                // Низкий уровень держится 1 мкс для записи 1
        DDRB &= ~(1 << PIN_DS1820);  // Настройка пина как вход (освобождение линии)
        _delay_us(60);               // Ожидание окончания временного слота
    } else {
        _delay_us(60);               // Низкий уровень держится 60 мкс для записи 0
        DDRB &= ~(1 << PIN_DS1820);  // Настройка пина как вход (освобождение линии)
        _delay_us(1);                // Короткая задержка для стабилизации
    }
}

/**
 * Чтение одного бита из шины OneWire
 *
 * Процедура:
 * 1. Инициирует временной слот (устанавливает линию в низкое состояние)
 * 2. Освобождает линию и включает подтягивающий резистор
 * 3. Ожидает 10 мкс и считывает состояние линии
 * 4. Завершает временной слот, ожидая оставшееся время
 *
 * @return 1, если на шине обнаружен высокий уровень, 0 - если низкий
 */
static inline uint8_t oneWireReadBit(void) {
    DDRB |= (1 << PIN_DS1820);    // Настройка пина как выход
    PORTB &= ~(1 << PIN_DS1820);  // Установка низкого уровня для начала временного слота
    _delay_us(1);                 // Короткий импульс для инициации чтения
    DDRB &= ~(1 << PIN_DS1820);   // Настройка пина как вход
    PORTB |= (1 << PIN_DS1820);   // Включение подтягивающего резистора
    _delay_us(10);  // Задержка перед чтением (устройство выдаёт данные через 15 мкс после начала слота)
    uint8_t result = (PINB & (1 << PIN_DS1820)) ? 1 : 0;  // Чтение значения бита
    _delay_us(53);  // Ожидание окончания временного слота (всего 60-70 мкс)
    return result;  // Возврат считанного бита
}

/**
 * Запись одного байта в шину OneWire
 *
 * Отправляет 8 бит последовательно, начиная с младшего (LSB)
 *
 * @param byte байт для записи на шину
 */
static inline void oneWireWriteByte(uint8_t byte) {
    for (uint8_t i = 0; i < 8; i++) {
        oneWireWriteBit(byte & 0x01);  // Запись младшего бита
        byte >>= 1;                    // Сдвиг вправо для доступа к следующему биту
    }
}

/**
 * Чтение одного байта из шины OneWire
 *
 * Считывает 8 бит последовательно. Биты считываются начиная с LSB,
 * но сохраняются в обратном порядке (старший бит в старшую позицию)
 *
 * @return считанный байт данных
 */
static inline uint8_t oneWireReadByte(void) {
    uint8_t result = 0;
    for (uint8_t i = 0; i < 8; i++) {
        result >>= 1;  // Освобождаем место для нового бита
        if (oneWireReadBit()) {
            result |= 0x80;  // Если считан 1, устанавливаем старший бит
        }
    }
    return result;  // Возврат собранного байта
}

/**
 * Поиск адресов датчиков на шине OneWire (алгоритм ROM Search)
 *
 * Реализует алгоритм поиска ROM-адресов на шине 1-Wire через
 * команду Search ROM (0xF0). Поддерживает поиск нескольких устройств
 * на одной шине с разрешением коллизий.
 *
 * @param roms двумерный массив для хранения 8-байтных ROM-адресов найденных устройств
 * @return количество найденных устройств (0-MAX_SENSORS)
 */
uint8_t oneWireSearch(uint8_t roms[][8]) {
    uint8_t count = 0, last = 0,
            done = 0;      // Счетчик найденных устройств, позиция последнего выбора, флаг завершения
    uint8_t rom[8] = {0};  // Текущий ROM-адрес

    while (!done && count < MAX_SENSORS) {
        if (!oneWireReset()) return count;  // Если устройств нет, возвращаем текущее количество
        oneWireWriteByte(0xF0);             // Команда Search ROM
        uint8_t disc = 0;                   // Позиция бита разветвления (для последующих поисков)

        // Перебираем все 64 бита ROM-адреса
        for (uint8_t i = 0; i < 64; i++) {
            uint8_t bit = oneWireReadBit();   // Читаем текущий бит всех устройств
            uint8_t comp = oneWireReadBit();  // Читаем комплементарный бит
            uint8_t val;                      // Значение, которое будем выбирать

            if (bit && comp) return count;  // Ошибка на шине, если оба бита 1

            if (!bit && !comp) {  // Конфликт - устройства имеют разные биты
                if (i < last)
                    val = (rom[i / 8] >> (i % 8)) & 1;  // Используем предыдущее решение
                else if (i == last)
                    val = 1;  // Если текущая позиция равна last, идем по ветке 1
                else {
                    val = 0;   // Иначе идем по ветке 0
                    disc = i;  // Запоминаем позицию разветвления
                }
            } else {
                val = bit;  // Если нет конфликта, используем прочитанный бит
            }

            oneWireWriteBit(val);  // Отправляем выбранный бит

            // Сохраняем бит в ROM-адрес
            if (val)
                rom[i / 8] |= (1 << (i % 8));  // Устанавливаем бит, если val=1
            else
                rom[i / 8] &= ~(1 << (i % 8));  // Сбрасываем бит, если val=0
        }

        // Копируем найденный адрес в массив результатов
        for (uint8_t i = 0; i < 8; i++) roms[count][i] = rom[i];
        count++;       // Увеличиваем счетчик найденных устройств
        last = disc;   // Сохраняем позицию последнего разветвления
        done = !disc;  // Если нет разветвлений, поиск завершен
    }
    return count;  // Возвращаем количество найденных устройств
}

/**
 * Инициализация программного UART
 *
 * Настраивает пин для передачи данных по UART:
 * - Устанавливает пин как выход
 * - Устанавливает высокий уровень (состояние в простое)
 */
static inline void uart_init(void) {
    DDRB |= (1 << PIN_UART_TX);   // Настройка пина как выход
    PORTB |= (1 << PIN_UART_TX);  // Установка высокого уровня (idle state)
}

/**
 * Отправка одного байта через программный UART
 *
 * Реализует побитную передачу без использования аппаратного UART:
 * 1. Отправляет стартовый бит (низкий уровень)
 * 2. Отправляет 8 бит данных, начиная с младшего (LSB)
 * 3. Отправляет стоповый бит (высокий уровень)
 *
 * @param data байт для отправки
 */
static inline void uart_transmit(uint8_t data) {
    PORTB &= ~(1 << PIN_UART_TX);  // Стартовый бит (низкий уровень)
    _delay_us(UART_DELAY);         // Задержка на длительность бита

    for (uint8_t i = 0; i < 8; i++) {
        if (data & 1)                     // Проверка младшего бита
            PORTB |= (1 << PIN_UART_TX);  // Установка высокого уровня, если бит = 1
        else
            PORTB &= ~(1 << PIN_UART_TX);  // Установка низкого уровня, если бит = 0
        _delay_us(UART_DELAY);             // Задержка на длительность бита
        data >>= 1;                        // Сдвиг для доступа к следующему биту
    }

    PORTB |= (1 << PIN_UART_TX);  // Стоповый бит (высокий уровень)
    _delay_us(UART_DELAY);        // Задержка на длительность бита
}

// Отправка температуры через UART в формате ASCII
// id: идентификатор датчика
// temp: температура в градусах Цельсия
static inline void uart_transmit_temp(uint8_t id, int16_t temp) {
    uart_transmit(id + '1'); // Вывод ID датчика (1, 2, 3, 4)
    uart_transmit(':');
    
    // Проверка на отрицательную температуру
    if (temp < 0) {
        uart_transmit('-');   // Выводим знак минус
        temp = -temp;         // Преобразуем в положительное число для обработки
    }
    
    // Таблица символов для цифр 0–9
    static const char digits[] = "0123456789";
    // Вычисление десятков и единиц без деления
    uint8_t tens = 0;
    while (temp >= 10) {
        temp -= 10;
        tens++;
    }
    if (tens > 0) {
        uart_transmit(digits[tens]); // Вывод десятков (если есть)
    }
    uart_transmit(digits[temp]); // Вывод единиц
    uart_transmit('C'); // Вывод 'C' вместо символа градуса
    uart_transmit('\r'); // Завершение строки (перевод каретки)
}

// Поиск датчиков на шине OneWire
static uint8_t roms[MAX_SENSORS][8];  // Статический массив для хранения адресов датчиков

int main(void) {
    // Инициализация портов ввода/вывода
    DDRB |= (1 << PIN_DS1820) | (1 << PIN_RELAY) | (1 << PIN_UART_TX);  // Настройка пинов как выходы
    PORTB &= ~(1 << PIN_RELAY);                                         // Реле изначально выключено
    uart_init();                                                        // Инициализация UART

    // Поиск датчиков на шине OneWire
    uint8_t count = oneWireSearch(roms);  // Поиск и подсчёт подключенных датчиков
    if (!count) {
        uart_transmit('N');  // Отправляем сообщение об отсутствии датчиков
        uart_transmit('\r');
        while (1);  // Бесконечный цикл, если датчики не найдены
    }

    register uint8_t relay = 0;  // Флаг состояния реле (0 - выключено)
    while (1) {
        register uint8_t above = 0, below = 1;  // Флаги для отслеживания пороговых значений
        if (oneWireReset()) {
            oneWireWriteByte(0xCC);  // Команда SKIP ROM (обращение ко всем устройствам)
            oneWireWriteByte(0x44);  // Команда запуска преобразования температуры
        }
        _delay_ms(850);  // Ожидаем завершения преобразования (не менее 750мс)

        // Чтение температуры с каждого найденного датчика
        for (uint8_t s = 0; s < count; s++) {
            if (oneWireReset()) {
                oneWireWriteByte(0x55);  // Команда MATCH ROM (обращение к конкретному устройству)
                for (uint8_t i = 0; i < 8; i++) oneWireWriteByte(roms[s][i]);  // Передача адреса устройства
                oneWireWriteByte(0xBE);            // Команда READ SCRATCHPAD (чтение памяти)
                uint8_t low = oneWireReadByte();   // Чтение младшего байта температуры
                uint8_t high = oneWireReadByte();  // Чтение старшего байта температуры
                int16_t temp = (high << 8) | low;  // Формирование 16-битного значения температуры
                temp = (temp << 4) >> 4;           // Правильная обработка знака (сохраняет знак при делении)
                temp >>= 4;                        // Деление на 16 (преобразование в градусы Цельсия)
                
                uart_transmit_temp(s, temp);       // Отправка показаний через UART

                // Проверка пороговых значений (учитываем только положительные температуры для порогов)
                if (temp > TEMP_UPPER_THRESHOLD) above = 1;   // Температура выше верхнего порога
                if (temp >= TEMP_LOWER_THRESHOLD) below = 0;  // Температура не ниже нижнего порога
            }
        }

        // Управление реле по гистерезису
        if (!relay && above) {
            PORTB |= (1 << PIN_RELAY);  // Включение реле при превышении верхнего порога
            relay = 1;
        } else if (relay && below) {
            PORTB &= ~(1 << PIN_RELAY);  // Выключение реле при опускании ниже нижнего порога
            relay = 0;
        }

        // Отправка текущего состояния реле через UART
        uart_transmit('R');
        uart_transmit(':');
        uart_transmit(relay + '0');  // Преобразование числа в ASCII символ
        uart_transmit('\r');
        _delay_ms(1000);  // Пауза 1 секунда между циклами опроса
    }
}